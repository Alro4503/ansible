- name: PRUEBA RÃPIDA - Limpieza /tmp con requeue forzado
  hosts: all
  become: yes
  gather_facts: no
  vars:
    ansible_become_exe: "sudo -n"
    ansible_become_flags: ""
    mtime_days: 1
    max_wait_minutes: 5  # âš¡ 5 minutos mÃ¡ximo de espera (instead de 24h)
    check_interval_seconds: 30  # âš¡ Verificar cada 30 segundos
    test_mode: true  # âš¡ Modo prueba - sin limpieza real de /tmp
    
  tasks:
    # ==================== FASE 1: DETECCIÃ“N Y PREPARACIÃ“N ====================
    - name: Obtener hostname completo del nodo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: Identificar jobs corriendo en este nodo
      shell: squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%j:%T" 2>/dev/null
      register: running_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar jobs encontrados para debugging
      debug:
        msg: 
          - "ğŸ” NODO: {{ hostname_full.stdout }}"
          - "ğŸ“Š JOBS ENCONTRADOS: {{ running_jobs.stdout_lines | length }}"
          - "ğŸ“ DETALLES: {{ running_jobs.stdout_lines }}"
      when: running_jobs.stdout != ""
      
    - name: Salir si no hay jobs (nada que hacer)
      meta: end_play
      when: running_jobs.stdout == ""
      
    # ==================== FASE 2: DRAIN Y ESPERA ====================
    - name: Poner nodo en estado DRAIN
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="PRUEBA REQUEUE - 5min timeout" || true
      register: drain_result
      failed_when: false
      
    - name: NotificaciÃ³n de inicio de prueba
      debug:
        msg:
          - "â° INICIANDO PRUEBA DE REQUEUE"
          - "ğŸ• Tiempo mÃ¡ximo de espera: {{ max_wait_minutes }} minutos"
          - "ğŸ” VerificaciÃ³n cada {{ check_interval_seconds }} segundos"
          - "ğŸ“‹ Jobs a monitorear: {{ running_jobs.stdout_lines }}"
          
    - name: Esperar tiempo limitado (5 minutos mÃ¡ximo)
      shell: squeue -h -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null
      register: remaining_jobs
      until: remaining_jobs.stdout == ""  # Hasta que no queden jobs
      retries: "{{ (max_wait_minutes * 60) / check_interval_seconds | int }}"  # 5min en intervalos de 30s
      delay: "{{ check_interval_seconds }}"  # 30 segundos entre intentos
      
    - name: Mostrar progreso de la espera
      debug:
        msg: 
          - "â³ Intento {{ remaining_jobs.attempt }}/{{ remaining_jobs.retries }}"
          - "ğŸ“Š Jobs restantes: {{ remaining_jobs.stdout_lines | length }}"
          - "ğŸ” Detalles: {{ remaining_jobs.stdout_lines }}"
      when: remaining_jobs.attempt > 1
      
    # ==================== FASE 3: REQUEUE FORZADO ====================
    - name: Forzar requeue de jobs pendientes despuÃ©s del timeout
      shell: |
        echo "ğŸš€ INICIANDO REQUEUE FORZADO"
        echo "ğŸ“‹ Jobs pendientes:"
        squeue -w {{ hostname_full.stdout }} -o "%.15i %.12u %.20j %.12T" 2>/dev/null || true
        
        # Requeuear cada job individualmente
        for jobid in $(squeue -h -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null); do
          echo "ğŸ”„ Requeueando job $jobid..."
          scancel --requeue $jobid
          sleep 2  # PequeÃ±a pausa entre jobs
        done
        
        echo "âœ… Requeue completado"
      args:
        executable: /bin/bash
      when: remaining_jobs.stdout != ""  # Solo si todavÃ­a hay jobs
      register: requeue_result
      failed_when: false
      
    - name: Esperar 1 minuto para que SLURM procese el requeue
      pause:
        minutes: 1
      when: requeue_result is defined
      
    # ==================== FASE 4: VERIFICACIÃ“N ====================
    - name: Verificar estado posterior al requeue
      shell: |
        echo "ğŸ“Š ESTADO FINAL EN ESTE NODO:"
        squeue -w {{ hostname_full.stdout }} -o "%.15i %.12u %.20j %.12T" 2>/dev/null || echo "âœ… No hay jobs en este nodo"
        
        echo ""
        echo "ğŸŒ JOBS DEL USUARIO EN OTROS NODOS:"
        # Buscar jobs del mismo usuario en otros nodos
        for job_line in "{{ running_jobs.stdout_lines }}"; do
          user=$(echo $job_line | cut -d: -f2)
          squeue -u $user -o "%.15i %.12u %.20j %.12N %.12T" 2>/dev/null || true
        done
      args:
        executable: /bin/bash
      register: final_verification
      
    # ==================== FASE 5: LIMPIEZA (OPCIONAL EN PRUEBA) ====================
    - name: Simular limpieza de /tmp (modo prueba)
      debug:
        msg: 
          - "ğŸ§¹ MODO PRUEBA: Limpieza de /tmp desactivada"
          - "ğŸ“ Se simularÃ­a eliminaciÃ³n de archivos > {{ mtime_days }} dÃ­as"
          - "âš¡ Para limpieza real, cambiar test_mode: false"
      when: test_mode
      
    - name: Limpieza real de /tmp (si se desactiva test_mode)
      shell: |
        find /tmp -type f -mtime +{{ mtime_days }} -delete 2>/dev/null || true
        find /tmp -type d -mtime +{{ mtime_days }} -exec rmdir {} + 2>/dev/null || true
      when: not test_mode
      register: cleanup_result
      failed_when: false
      
    # ==================== FASE 6: REACTIVACIÃ“N Y REPORTE ====================
    - name: Reactivar el nodo
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=RESUME
      register: resume_result
      failed_when: false
      
    - name: Resultado final de la prueba
      debug:
        msg:
          - "ğŸ‰ PRUEBA DE REQUEUE COMPLETADA"
          - "ğŸ“‹ Nodo: {{ hostname_full.stdout }}"
          - "ğŸ”¢ Jobs iniciales: {{ running_jobs.stdout_lines | length }}"
          - "ğŸ”„ Jobs requeueados: {{ requeue_result.stdout_lines | length if requeue_result is defined else '0' }}"
          - "â±ï¸  Tiempo de espera: {{ max_wait_minutes }} minutos"
          - "âœ… Estado final: {{ final_verification.stdout }}"
          - "ğŸ”§ Nodo reactivado: {{ resume_result.rc == 0 | ternary('SI','NO') }}"
