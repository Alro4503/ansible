- name: Requeue automático con control de tiempo, timeout, limpieza /tmp y gestión de nodos
  hosts: all
  become: yes
  vars:
    ansible_become_exe: "sudo -n"
    tmp_size_limit_gb: 0.1  # Límite en GB para /tmp por usuario
    wait_timeout_minutes: 1  # Timeout para esperar que jobs terminen normalmente (1 min para pruebas)
    mtime_days: 1  # Días para considerar archivos antiguos en /tmp
    systemd_paths:
      - "/tmp/systemd-*"
      - "/tmp/.font-unix*"
      - "/tmp/.ICE-unix*" 
      - "/tmp/.Test-unix*"
      - "/tmp/.X11-unix*"
      - "/tmp/.XIM-unix*"
      - "/tmp/snap-private-tmp*"
    
  tasks:
    # === FASE 1: DETECCIÓN Y DRÁINEO INMEDIATO ===
    - name: Obtener hostname completo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: DRÁINEO INMEDIATO DEL NODO (BLOQUEAR NUEVOS JOBS)
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="Auto-requeue: mantenimiento programado"
      register: drain_result
      failed_when: false
      
    - name: Verificar estado del dráineo
      shell: |
        sinfo -n {{ hostname_full.stdout }} -h -o "%t"
      register: node_state_after_drain
      changed_when: false
      
    - name: Mostrar estado del nodo después del dráineo
      debug:
        msg: "Estado del nodo {{ hostname_full.stdout }} después del dráineo: {{ node_state_after_drain.stdout }}"
      
    - name: Esperar 5 segundos para que Slurm procese el dráineo
      pause:
        seconds: 5
      
    - name: Detectar usuarios con archivos grandes en /tmp
      shell: |
        for file in /tmp/*; do
          if [ -e "$file" ]; then
            size_kb=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
            owner=$(stat -c '%U' "$file" 2>/dev/null)
            
            if [ ! -z "$size_kb" ] && [ ! -z "$owner" ]; then
              size_gb=$(echo "scale=2; $size_kb / 1024 / 1024" | bc)
              over_limit=$(echo "$size_gb > {{ tmp_size_limit_gb }}" | bc)
              
              if [ "$over_limit" -eq 1 ]; then
                echo "$owner $size_gb"
              fi
            fi
          fi
        done | awk '{users[$1]+=$2} END {for (u in users) if (users[u] > {{ tmp_size_limit_gb }}) print u, users[u]}' | sort -u
      register: problematic_users
      changed_when: false
      failed_when: false
      
    - name: Crear archivo temporal con usuarios problemáticos
      shell: |
        echo "{{ problematic_users.stdout }}" > /tmp/problematic_users.txt
      when: problematic_users.stdout != ""
      
    - name: Mostrar usuarios problemáticos
      debug:
        msg: |
          ⚠️  Usuarios con uso excesivo de /tmp (>{{ tmp_size_limit_gb }}GB):
          {% if problematic_users.stdout_lines | length > 0 %}
          {% for line in problematic_users.stdout_lines %}
            - {{ line }}
          {% endfor %}
          {% else %}
            Ninguno detectado
          {% endif %}
      
    - name: Encontrar nodo alternativo
      shell: |
        sinfo -p short -h -o "%N" | tr ',' '\n' | grep -v {{ hostname_full.stdout }} | grep -v down | head -1 || echo "NO_ALTERNATIVE"
      register: alternative_node
      changed_when: false
      failed_when: false
      
    - name: Verificar jobs en el nodo (DESPUÉS del dráineo)
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%T" 2>/dev/null || echo ""
      register: all_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar estado actual
      debug:
        msg: |
          Nodo actual: {{ hostname_full.stdout }}
          Estado del nodo: {{ node_state_after_drain.stdout }}
          Nodo alternativo: {{ alternative_node.stdout }}
          Jobs encontrados: {{ all_jobs.stdout_lines | length }}
          Usuarios problemáticos: {{ problematic_users.stdout_lines | length }}
          Timeout de espera: {{ wait_timeout_minutes }} minutos
        
    # === FASE 2: GESTIÓN DE JOBS (solo si hay jobs) ===
    - name: Notificar inicio de proceso con timeout (solo si hay jobs)
      debug:
        msg: |
          🕒 INICIANDO PROCESO CON TIMEOUT
          Nodo en estado DRAIN - No se aceptan nuevos jobs
          Se esperará {{ wait_timeout_minutes }} minuto(s) para que los jobs existentes terminen normalmente
          Si no completan en ese tiempo, se procederá con requeue/cancelación
      when: all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
          
    - name: Esperar que jobs terminen normalmente (con timeout) - SOLO SI HAY JOBS
      shell: |
        timeout_seconds=$(( {{ wait_timeout_minutes }} * 60 ))
        end_time=$(( $(date +%s) + $timeout_seconds ))
        
        echo "⏳ Esperando máximo {{ wait_timeout_minutes }} minuto(s) para jobs existentes..."
        
        while [ $(date +%s) -lt $end_time ]; do
          remaining_jobs=$(squeue -h -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null | wc -l)
          
          if [ $remaining_jobs -eq 0 ]; then
            echo "✅ Todos los jobs completaron normalmente"
            exit 0
          fi
          
          echo "  Jobs pendientes: $remaining_jobs - Tiempo restante: $(( (end_time - $(date +%s)) / 60 )) min"
          sleep 30
        done
        
        echo "⏰ Timeout alcanzado. Procediendo con acciones..."
        exit 1
      register: wait_result
      changed_when: false
      failed_when: wait_result.rc != 0 and wait_result.rc != 1
      when: all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
      
    - name: Verificar si quedan jobs después del timeout - SOLO SI HABÍA JOBS INICIALMENTE
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u" 2>/dev/null || echo ""
      register: remaining_jobs
      changed_when: false
      failed_when: false
      when: 
        - all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
        - wait_result.rc == 1  # Solo si timeout se alcanzó

    # === FASE 3: GESTIÓN DE JOBS (cancelación y requeue - solo si hay jobs pendientes) ===
    - name: Cancelar jobs de usuarios problemáticos (después de timeout)
      shell: |
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "🚫 Cancelando jobs de usuarios con /tmp excesivo..."
        cancelled_count=0
        
        {% for job_line in remaining_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        if [ $is_problematic -eq 1 ]; then
          echo "  ❌ Cancelando job $jobid del usuario problemático $jobuser"
          scancel $jobid
          cancelled_count=$((cancelled_count + 1))
        fi
        {% endfor %}
        
        echo "Total cancelados: $cancelled_count"
      args:
        executable: /bin/bash
      register: cancel_result
      when: 
        - all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
        - wait_result.rc == 1 
        - problematic_users.stdout_lines | length > 0 
        - remaining_jobs.stdout_lines | length > 0
      
    - name: Esperar que se cancelen los jobs
      pause:
        seconds: 10
      when: 
        - all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
        - wait_result.rc == 1 
        - problematic_users.stdout_lines | length > 0 
        - remaining_jobs.stdout_lines | length > 0
          
    - name: Requeuear jobs restantes después de timeout (usuarios limpios) con cambio de nodo
      shell: |
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "♻️  Requeuing jobs de usuarios sin problemas (después de timeout)..."
        requeued_count=0
        
        {% for job_line in remaining_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        if [ $is_problematic -eq 0 ]; then
          echo "  ✅ Requeuing job $jobid del usuario $jobuser"
          
          {% if alternative_node.stdout != "NO_ALTERNATIVE" %}
          job_script=$(scontrol show job $jobid | grep "Command=" | sed 's/.*Command=//')
          
          if [ ! -z "$job_script" ] && [ -f "$job_script" ]; then
            echo "    Moviendo a nodo {{ alternative_node.stdout }}"
            scancel $jobid
            sleep 2
            sbatch --nodelist={{ alternative_node.stdout }} "$job_script"
            requeued_count=$((requeued_count + 1))
          else
            echo "    Requeue normal (no se pudo obtener script)"
            scontrol requeue $jobid 2>/dev/null || true
          fi
          {% else %}
          echo "    Requeue sin cambio de nodo"
          scontrol requeue $jobid
          requeued_count=$((requeued_count + 1))
          {% endif %}
        fi
        {% endfor %}
        
        echo "Total requeued: $requeued_count"
      args:
        executable: /bin/bash
      register: requeue_result
      failed_when: false
      when: 
        - all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
        - wait_result.rc == 1 
        - remaining_jobs.stdout_lines | length > 0
          
    - name: Esperar que los jobs se requeueen
      pause:
        seconds: 30
      when: 
        - all_jobs.stdout != "" and all_jobs.stdout_lines | length > 0
        - wait_result.rc == 1 
        - remaining_jobs.stdout_lines | length > 0

    # === FASE 4: LIMPIEZA AUTOMÁTICA DE /TMP (SIEMPRE SE EJECUTA) ===
    - name: Mostrar uso actual de /tmp antes de limpieza
      shell: df -h /tmp
      register: initial_usage
      changed_when: false
      
    - name: Buscar archivos antiguos para eliminar (sin .time)
      shell: |
        find /tmp -type f -mtime +{{ mtime_days }} \
        ! -name "*.time" \
        ! -name "aquota.user" \
        ! -name "aquota.group" \
        ! -name "krb5cc*" \
        ! -path "/tmp/systemd-*" \
        ! -path "/tmp/.font-unix*" \
        ! -path "/tmp/.ICE-unix*" \
        ! -path "/tmp/.Test-unix*" \
        ! -path "/tmp/.X11-unix*" \
        ! -path "/tmp/.XIM-unix*" \
        ! -path "/tmp/snap-private-tmp*" | wc -l
      register: old_files_count
      become: yes
      
    - name: Eliminar archivos antiguos directamente
      shell: |
        find /tmp -type f -mtime +{{ mtime_days }} \
        ! -name "*.time" \
        ! -name "aquota.user" \
        ! -name "aquota.group" \
        ! -name "krb5cc*" \
        ! -path "/tmp/systemd-*" \
        ! -path "/tmp/.font-unix*" \
        ! -path "/tmp/.ICE-unix*" \
        ! -path "/tmp/.Test-unix*" \
        ! -path "/tmp/.X11-unix*" \
        ! -path "/tmp/.XIM-unix*" \
        ! -path "/tmp/snap-private-tmp*" \
        -delete 2>/dev/null || true
      register: delete_files_result
      become: yes
      when: old_files_count.stdout|int > 0
      failed_when: false  # No fallar por errores de permisos
      
    - name: Buscar directorios antiguos para eliminar
      shell: |
        find /tmp -type d -mtime +{{ mtime_days }} \
        ! -path "/tmp/systemd-*" \
        ! -path "/tmp/.font-unix*" \
        ! -path "/tmp/.ICE-unix*" \
        ! -path "/tmp/.Test-unix*" \
        ! -path "/tmp/.X11-unix*" \
        ! -path "/tmp/.XIM-unix*" \
        ! -path "/tmp/snap-private-tmp*" \
        ! -path "/tmp" | wc -l
      register: old_dirs_count
      become: yes
      
    - name: Eliminar directorios antiguos
      shell: |
        find /tmp -type d -mtime +{{ mtime_days }} \
        ! -path "/tmp/systemd-*" \
        ! -path "/tmp/.font-unix*" \
        ! -path "/tmp/.ICE-unix*" \
        ! -path "/tmp/.Test-unix*" \
        ! -path "/tmp/.X11-unix*" \
        ! -path "/tmp/.XIM-unix*" \
        ! -path "/tmp/snap-private-tmp*" \
        ! -path "/tmp" \
        -exec rmdir {} + 2>/dev/null || true
      register: delete_dirs_result
      become: yes
      when: old_dirs_count.stdout|int > 0
      failed_when: false

    # === FASE 5: FINALIZACIÓN Y REACTIVACIÓN ===
    - name: Mostrar uso final de /tmp después de limpieza
      shell: df -h /tmp
      register: final_usage
      changed_when: false
      
    - name: Reactivar nodo - CORREGIDO
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=IDLE
      register: resume_result
      failed_when: false
      
    - name: Verificar estado final del nodo
      shell: |
        sinfo -n {{ hostname_full.stdout }} -h -o "%t"
      register: final_node_state
      changed_when: false
      
    - name: Limpiar archivo temporal de usuarios problemáticos
      file:
        path: /tmp/problematic_users.txt
        state: absent
      
    - name: Resultado final completo
      debug:
        msg: |
          {% if all_jobs.stdout == "" or all_jobs.stdout_lines | length == 0 %}
          "✅ NO HABÍA JOBS - SOLO LIMPIEZA EJECUTADA"
          "=== LIMPIEZA /TMP ==="
          "Archivos eliminados: {{ old_files_count.stdout }}"
          "Directorios eliminados: {{ old_dirs_count.stdout }}"
          "Uso inicial: {{ initial_usage.stdout_lines[-1] | default('N/A') }}"
          "Uso final: {{ final_usage.stdout_lines[-1] | default('N/A') }}"
          {% elif wait_result.rc == 0 %}
          "✅ TODOS LOS JOBS COMPLETARON NORMALMENTE + LIMPIEZA EJECUTADA"
          "Jobs originales: {{ all_jobs.stdout_lines | length }}"
          "=== LIMPIEZA /TMP ==="
          "Archivos eliminados: {{ old_files_count.stdout }}"
          "Directorios eliminados: {{ old_dirs_count.stdout }}"
          {% else %}
          "🎯 PROCESO COMPLETADO EN {{ hostname_full.stdout }}"
          "=== GESTIÓN DE JOBS ==="
          "Jobs originales: {{ all_jobs.stdout_lines | length }}"
          "Jobs pendientes después de timeout: {{ remaining_jobs.stdout_lines | length }}"
          "Usuarios problemáticos: {{ problematic_users.stdout_lines | length }}"
          "Nodo destino: {{ alternative_node.stdout }}"
          "=== LIMPIEZA /TMP ==="
          "Archivos eliminados: {{ old_files_count.stdout }}"
          "Directorios eliminados: {{ old_dirs_count.stdout }}"
          "Uso inicial: {{ initial_usage.stdout_lines[-1] | default('N/A') }}"
          "Uso final: {{ final_usage.stdout_lines[-1] | default('N/A') }}"
          "=== ESTADO NODO ==="
          "Nodo reactivado: {{ '✅ SÍ' if final_node_state.stdout == 'idle' or final_node_state.stdout == 'mix' or final_node_state.stdout == 'alloc' else '❌ NO - Estado: ' + final_node_state.stdout }}"
          {% endif %}
