- name: Requeue autom√°tico CON CAMBIO DE NODO y control de /tmp
  hosts: all
  become: yes
  vars:
    ansible_become_exe: "sudo -n"
    tmp_size_limit_gb: 1  # L√≠mite en GB para /tmp por usuario
    
  tasks:
    - name: Obtener hostname completo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: Detectar usuarios con archivos grandes en /tmp
      shell: |
        # Inicializar array asociativo para usuarios
        declare -A user_sizes
        
        for file in /tmp/* /tmp/.*; do
          # Saltar . y ..
          if [[ "$file" == "/tmp/." || "$file" == "/tmp/.." ]]; then
            continue
          fi
          
          if [ -e "$file" ]; then
            size_kb=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
            owner=$(stat -c '%U' "$file" 2>/dev/null 2>/dev/null || echo "unknown")
            
            if [ ! -z "$size_kb" ] && [ ! -z "$owner" ] && [ "$owner" != "unknown" ]; then
              size_gb=$(echo "scale=2; $size_kb / 1024 / 1024" | bc 2>/dev/null || echo "0")
              
              # Solo procesar si bc funcion√≥
              if [[ ! -z "$size_gb" && "$size_gb" != "0" ]]; then
                # Comparar con l√≠mite
                over_limit=$(echo "$size_gb > {{ tmp_size_limit_gb }}" | bc 2>/dev/null || echo "0")
                
                if [ "$over_limit" -eq 1 ]; then
                  user_sizes["$owner"]=$(echo "${user_sizes[$owner]:-0} + $size_gb" | bc 2>/dev/null || echo "${user_sizes[$owner]:-0}")
                fi
              fi
            fi
          fi
        done
        
        # Imprimir usuarios que superan el l√≠mite
        for user in "${!user_sizes[@]}"; do
          total_size=${user_sizes[$user]}
          limit_check=$(echo "$total_size > {{ tmp_size_limit_gb }}" | bc 2>/dev/null || echo "0")
          if [ "$limit_check" -eq 1 ]; then
            echo "$user $total_size"
          fi
        done
      register: problematic_users
      changed_when: false
      failed_when: false
      
    - name: Mostrar usuarios problem√°ticos
      debug:
        msg: |
          "‚ö†Ô∏è  Usuarios con uso excesivo de /tmp (>{{ tmp_size_limit_gb }}GB):"
          {% if problematic_users.stdout_lines | length > 0 %}
          {% for line in problematic_users.stdout_lines %}
          "  - {{ line }}"
          {% endfor %}
          {% else %}
          "  Ninguno detectado"
          {% endif %}
      
    - name: Encontrar nodo alternativo
      shell: |
        sinfo -p short -h -o "%N" | tr ',' '\n' | grep -v {{ hostname_full.stdout }} | grep -v down | head -1 || echo "NO_ALTERNATIVE"
      register: alternative_node
      changed_when: false
      failed_when: false
      
    - name: Verificar jobs en este nodo
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%j:%T:%N:%P" 2>/dev/null || echo "NO_JOBS"
      register: running_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar estado actual
      debug:
        msg: |
          "Nodo actual: {{ hostname_full.stdout }}"
          "Nodo alternativo: {{ alternative_node.stdout }}"
          "Jobs encontrados: {{ running_jobs.stdout_lines if running_jobs.stdout != 'NO_JOBS' else 'NINGUNO' }}"
        
    - name: Salir si no hay jobs
      debug:
        msg: "‚úÖ No hay jobs en {{ hostname_full.stdout }} - nada que hacer"
      when: running_jobs.stdout == "NO_JOBS" or running_jobs.stdout == ""
      
    - name: Continuar si hay jobs
      block:
        - name: Extraer lista de usuarios problem√°ticos
          set_fact:
            problematic_users_list: "{{ problematic_users.stdout_lines | map('regex_replace', '^(\\S+).*', '\\1') | list }}"
          when: problematic_users.stdout_lines | length > 0
          
        - name: Inicializar lista vac√≠a si no hay usuarios problem√°ticos
          set_fact:
            problematic_users_list: []
          when: problematic_users.stdout_lines | length == 0
        
        - name: Cancelar jobs de usuarios problem√°ticos
          shell: |
            echo "üö´ Cancelando jobs de usuarios con /tmp excesivo..."
            {% if problematic_users_list | length > 0 %}
            {% for user in problematic_users_list %}
            echo "  Cancelando jobs de {{ user }}"
            # Obtener y cancelar jobs del usuario
            user_jobs=$(squeue -h -u {{ user }} -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null)
            if [ ! -z "$user_jobs" ]; then
              echo "    Jobs encontrados: $user_jobs"
              scancel -u {{ user }} -w {{ hostname_full.stdout }}
              echo "    Jobs cancelados para {{ user }}"
            else
              echo "    No hay jobs activos para {{ user }}"
            fi
            {% endfor %}
            {% else %}
            echo "‚úÖ No hay usuarios problem√°ticos - no se cancela ning√∫n job"
            {% endif %}
          args:
            executable: /bin/bash
          register: cancel_result
          failed_when: false
          
        - name: Esperar que se cancelen los jobs
          pause:
            seconds: 10
          when: problematic_users_list | length > 0
          
        - name: Drainear nodo
          shell: |
            echo "üîß Draneando nodo {{ hostname_full.stdout }}..."
            scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="Auto-requeue mantenimiento"
          register: drain_result
          failed_when: false
          
        - name: Verificar estado del draneo
          shell: |
            sinfo -n {{ hostname_full.stdout }} -h -o "%t"
          register: node_state
          changed_when: false
          
        - name: Mostrar estado del nodo
          debug:
            msg: "Estado del nodo {{ hostname_full.stdout }}: {{ node_state.stdout }}"
          
        - name: Esperar 15 segundos para que los jobs terminen
          pause:
            seconds: 15
          
        - name: Requeuear jobs restantes (SOLO usuarios no problem√°ticos)
          shell: |
            echo "üîÑ Requeueando jobs de usuarios no problem√°ticos..."
            # Obtener todos los jobs restantes en el nodo
            remaining_jobs=$(squeue -h -w {{ hostname_full.stdout }} -o "%i:%u" 2>/dev/null)
            
            if [ -z "$remaining_jobs" ]; then
              echo "‚úÖ No hay jobs restantes para requeue"
              exit 0
            fi
            
            echo "$remaining_jobs" | while IFS=: read jobid jobuser; do
              # Verificar si el usuario es problem√°tico
              is_problematic=0
              {% for puser in problematic_users_list %}
              if [ "{{ puser }}" = "$jobuser" ]; then
                is_problematic=1
              fi
              {% endfor %}
              
              if [ $is_problematic -eq 1 ]; then
                echo "‚è≠Ô∏è  Saltando job $jobid del usuario problem√°tico $jobuser"
              else
                echo "‚úÖ Procesando job $jobid del usuario $jobuser"
                {% if alternative_node.stdout != "NO_ALTERNATIVE" %}
                  echo "  Moviendo job $jobid a {{ alternative_node.stdout }}"
                  # Primero obtener los detalles del job antes de cancelar
                  job_info=$(scontrol show job $jobid)
                  if [ $? -eq 0 ]; then
                    # Cancelar y resubmit en nuevo nodo
                    scancel $jobid
                    sleep 2
                    # Recrear el job con el nuevo nodo
                    scontrol show job $jobid | grep "Command=" | cut -d= -f2 | xargs sbatch --nodelist={{ alternative_node.stdout }}
                  else
                    echo "  ‚ùå No se pudo obtener info del job $jobid"
                  fi
                {% else %}
                  echo "  üîÑ Requeue normal del job $jobid"
                  scontrol requeue $jobid
                {% endif %}
              fi
            done
          args:
            executable: /bin/bash
          register: requeue_result
          failed_when: false
          
        - name: Esperar 30 segundos para que se completen los requeues
          pause:
            seconds: 30
          
        - name: Reactivar nodo
          shell: |
            echo "üîÑ Reactivando nodo {{ hostname_full.stdout }}..."
            scontrol update NodeName={{ hostname_full.stdout }} State=RESUME
          register: resume_result
          failed_when: false
          
        - name: Verificar estado final del nodo
          shell: |
            sinfo -n {{ hostname_full.stdout }} -h -o "%t"
          register: final_node_state
          changed_when: false
          
        - name: Resultado final
          debug:
            msg:
              - "‚úÖ REQUEUE COMPLETADO en {{ hostname_full.stdout }}"
              - "Usuarios problem√°ticos detectados: {{ problematic_users_list }}"
              - "Jobs cancelados (usuarios problem√°ticos): {{ problematic_users_list | length }}"
              - "Nodo destino: {{ alternative_node.stdout }}"
              - "Estado final del nodo: {{ final_node_state.stdout }}"
      when: running_jobs.stdout != "NO_JOBS" and running_jobs.stdout != ""
