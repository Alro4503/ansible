- name: Requeue automático con control de tiempo y /tmp
  hosts: all
  become: yes
  vars:
    ansible_become_exe: "sudo -n"
    tmp_size_limit_gb: 0.1  # Límite en GB para /tmp por usuario (100MB para pruebas)
    time_limit_minutes: 5   # Jobs que superen este tiempo serán requeued (5 min para pruebas)
    
  tasks:
    - name: Obtener hostname completo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: Detectar usuarios con archivos grandes en /tmp
      shell: |
        for file in /tmp/*; do
          if [ -e "$file" ]; then
            size_kb=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
            owner=$(stat -c '%U' "$file" 2>/dev/null)
            
            if [ ! -z "$size_kb" ] && [ ! -z "$owner" ]; then
              size_gb=$(echo "scale=2; $size_kb / 1024 / 1024" | bc)
              over_limit=$(echo "$size_gb > {{ tmp_size_limit_gb }}" | bc)
              
              if [ "$over_limit" -eq 1 ]; then
                echo "$owner $size_gb"
              fi
            fi
          fi
        done | awk '{users[$1]+=$2} END {for (u in users) if (users[u] > {{ tmp_size_limit_gb }}) print u, users[u]}' | sort -u
      register: problematic_users
      changed_when: false
      failed_when: false
      
    - name: Crear archivo temporal con usuarios problemáticos
      shell: |
        echo "{{ problematic_users.stdout }}" > /tmp/problematic_users.txt
      when: problematic_users.stdout != ""
      
    - name: Mostrar usuarios problemáticos
      debug:
        msg: |
          ⚠️  Usuarios con uso excesivo de /tmp (>{{ tmp_size_limit_gb }}GB):
          {% if problematic_users.stdout_lines | length > 0 %}
          {% for line in problematic_users.stdout_lines %}
            - {{ line }}
          {% endfor %}
          {% else %}
            Ninguno detectado
          {% endif %}
      
    - name: Encontrar nodo alternativo
      shell: |
        sinfo -p short -h -o "%N" | tr ',' '\n' | grep -v {{ hostname_full.stdout }} | grep -v down | head -1 || echo "NO_ALTERNATIVE"
      register: alternative_node
      changed_when: false
      failed_when: false
      
    - name: Verificar jobs que exceden tiempo límite
      shell: |
        time_limit_minutes={{ time_limit_minutes }}
        
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%M" 2>/dev/null | while IFS=: read jobid user elapsed; do
          # Convertir tiempo elapsed a minutos
          if echo "$elapsed" | grep -q "-"; then
            days=$(echo "$elapsed" | cut -d- -f1)
            time_part=$(echo "$elapsed" | cut -d- -f2)
            hours=$(echo "$time_part" | cut -d: -f1)
            minutes=$(echo "$time_part" | cut -d: -f2)
            total_minutes=$((days * 24 * 60 + hours * 60 + minutes))
          elif [ $(echo "$elapsed" | tr -cd ':' | wc -c) -eq 2 ]; then
            hours=$(echo "$elapsed" | cut -d: -f1)
            minutes=$(echo "$elapsed" | cut -d: -f2)
            total_minutes=$((hours * 60 + minutes))
          else
            minutes=$(echo "$elapsed" | cut -d: -f1)
            total_minutes=$minutes
          fi
          
          if [ $total_minutes -gt $time_limit_minutes ]; then
            echo "$jobid:$user:$elapsed:$total_minutes"
          fi
        done
      register: long_running_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar estado actual
      debug:
        msg: |
          Nodo actual: {{ hostname_full.stdout }}
          Nodo alternativo: {{ alternative_node.stdout }}
          Jobs con tiempo excedido: {{ long_running_jobs.stdout_lines | length }}
          {% if long_running_jobs.stdout_lines | length > 0 %}
          Detalles:
          {% for job in long_running_jobs.stdout_lines %}
            - Job {{ job.split(':')[0] }} del usuario {{ job.split(':')[1] }} - Tiempo: {{ job.split(':')[2] }}
          {% endfor %}
          {% endif %}
        
    - name: Salir si no hay jobs que procesar
      meta: end_play
      when: long_running_jobs.stdout == "" or long_running_jobs.stdout_lines | length == 0
      
    - name: DRAINEAR NODO al inicio del proceso
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="Auto-requeue: procesando jobs con tiempo excedido"
      register: drain_result
      failed_when: false
      
    - name: Esperar que el drain se aplique
      pause:
        seconds: 5
        
    - name: Cancelar jobs de usuarios problemáticos que exceden tiempo
      shell: |
        # Leer usuarios problemáticos
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "🚫 Cancelando jobs de usuarios con /tmp excesivo..."
        cancelled_count=0
        
        # Procesar cada job que excede tiempo
        {% for job_line in long_running_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        # Verificar si el usuario es problemático
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        if [ $is_problematic -eq 1 ]; then
          echo "  ❌ Cancelando job $jobid del usuario problemático $jobuser"
          scancel $jobid
          cancelled_count=$((cancelled_count + 1))
        fi
        {% endfor %}
        
        echo "CANCELLED_COUNT:$cancelled_count"
      args:
        executable: /bin/bash
      register: cancel_result
      when: problematic_users.stdout_lines | length > 0
      
    - name: Esperar que se cancelen los jobs
      pause:
        seconds: 10
      when: problematic_users.stdout_lines | length > 0
          
    - name: Requeuear jobs restantes (usuarios limpios) con cambio de nodo
      shell: |
        # Leer usuarios problemáticos
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "♻️  Requeuing jobs de usuarios sin problemas..."
        requeued_count=0
        
        # Procesar cada job que excede tiempo
        {% for job_line in long_running_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        # Verificar si el usuario es problemático
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        # Solo requeue si NO es problemático
        if [ $is_problematic -eq 0 ]; then
          echo "  ✅ Requeuing job $jobid del usuario $jobuser"
          
          {% if alternative_node.stdout != "NO_ALTERNATIVE" %}
          # Obtener comando del job
          job_script=$(scontrol show job $jobid | grep "Command=" | sed 's/.*Command=//')
          
          if [ ! -z "$job_script" ] && [ -f "$job_script" ]; then
            echo "    Moviendo a nodo {{ alternative_node.stdout }}"
            scancel $jobid
            sleep 2
            sbatch --nodelist={{ alternative_node.stdout }} "$job_script"
            requeued_count=$((requeued_count + 1))
          else
            echo "    ⚠️  No se pudo obtener script, requeue normal"
            scontrol requeue $jobid 2>/dev/null || true
          fi
          {% else %}
          echo "    Requeue sin cambio de nodo"
          scontrol requeue $jobid
          requeued_count=$((requeued_count + 1))
          {% endif %}
        fi
        {% endfor %}
        
        echo "REQUEUED_COUNT:$requeued_count"
      args:
        executable: /bin/bash
      register: requeue_result
      failed_when: false
          
    - name: Esperar que los jobs se requeueen
      pause:
        seconds: 30
          
    - name: Reactivar nodo
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=RESUME
      register: resume_result
      failed_when: false
      
    - name: Limpiar archivo temporal
      file:
        path: /tmp/problematic_users.txt
        state: absent
      
    - name: Resultado final
      debug:
        msg:
          - "✅ PROCESO COMPLETADO en {{ hostname_full.stdout }}"
          - "Jobs con tiempo excedido: {{ long_running_jobs.stdout_lines | length }}"
          - "Usuarios problemáticos: {{ problematic_users.stdout_lines | length }}"
          - "Jobs cancelados: {{ cancel_result.stdout_lines | select('search', 'CANCELLED_COUNT') | first | default('CANCELLED_COUNT:0') | regex_replace('CANCELLED_COUNT:', '') }}"
          - "Jobs requeued: {{ requeue_result.stdout_lines | select('search', 'REQUEUED_COUNT') | first | default('REQUEUED_COUNT:0') | regex_replace('REQUEUED_COUNT:', '') }}"
          - "Nodo destino: {{ alternative_node.stdout }}"
