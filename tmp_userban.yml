- name: Requeue autom√°tico con control de tiempo, timeout y /tmp
  hosts: all
  become: yes
  vars:
    ansible_become_exe: "sudo -n"
    tmp_size_limit_gb: 0.1  # L√≠mite en GB para /tmp por usuario
    wait_timeout_minutes: 1  # Timeout para esperar que jobs terminen normalmente (1 min para pruebas)
    
  tasks:
    - name: Obtener hostname completo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: Detectar usuarios con archivos grandes en /tmp
      shell: |
        for file in /tmp/*; do
          if [ -e "$file" ]; then
            size_kb=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
            owner=$(stat -c '%U' "$file" 2>/dev/null)
            
            if [ ! -z "$size_kb" ] && [ ! -z "$owner" ]; then
              size_gb=$(echo "scale=2; $size_kb / 1024 / 1024" | bc)
              over_limit=$(echo "$size_gb > {{ tmp_size_limit_gb }}" | bc)
              
              if [ "$over_limit" -eq 1 ]; then
                echo "$owner $size_gb"
              fi
            fi
          fi
        done | awk '{users[$1]+=$2} END {for (u in users) if (users[u] > {{ tmp_size_limit_gb }}) print u, users[u]}' | sort -u
      register: problematic_users
      changed_when: false
      failed_when: false
      
    - name: Crear archivo temporal con usuarios problem√°ticos
      shell: |
        echo "{{ problematic_users.stdout }}" > /tmp/problematic_users.txt
      when: problematic_users.stdout != ""
      
    - name: Mostrar usuarios problem√°ticos
      debug:
        msg: |
          ‚ö†Ô∏è  Usuarios con uso excesivo de /tmp (>{{ tmp_size_limit_gb }}GB):
          {% if problematic_users.stdout_lines | length > 0 %}
          {% for line in problematic_users.stdout_lines %}
            - {{ line }}
          {% endfor %}
          {% else %}
            Ninguno detectado
          {% endif %}
      
    - name: Encontrar nodo alternativo
      shell: |
        sinfo -p short -h -o "%N" | tr ',' '\n' | grep -v {{ hostname_full.stdout }} | grep -v down | head -1 || echo "NO_ALTERNATIVE"
      register: alternative_node
      changed_when: false
      failed_when: false
      
    - name: Verificar jobs en el nodo
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%T" 2>/dev/null || echo ""
      register: all_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar estado actual
      debug:
        msg: |
          Nodo actual: {{ hostname_full.stdout }}
          Nodo alternativo: {{ alternative_node.stdout }}
          Jobs encontrados: {{ all_jobs.stdout_lines | length }}
          Usuarios problem√°ticos: {{ problematic_users.stdout_lines | length }}
          Timeout de espera: {{ wait_timeout_minutes }} minutos
        
    - name: Salir si no hay jobs que procesar
      meta: end_play
      when: all_jobs.stdout == "" or all_jobs.stdout_lines | length == 0

    - name: Notificar inicio de proceso con timeout
      debug:
        msg: |
          üïí INICIANDO PROCESO CON TIMEOUT
          Se esperar√° {{ wait_timeout_minutes }} minuto(s) para que los jobs terminen normalmente
          Si no completan en ese tiempo, se proceder√° con requeue/cancelaci√≥n
          
    - name: Esperar que jobs terminen normalmente (con timeout)
      shell: |
        timeout_seconds=$(( {{ wait_timeout_minutes }} * 60 ))
        end_time=$(( $(date +%s) + $timeout_seconds ))
        
        echo "‚è≥ Esperando m√°ximo {{ wait_timeout_minutes }} minuto(s)..."
        
        while [ $(date +%s) -lt $end_time ]; do
          remaining_jobs=$(squeue -h -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null | wc -l)
          
          if [ $remaining_jobs -eq 0 ]; then
            echo "‚úÖ Todos los jobs completaron normalmente"
            exit 0
          fi
          
          echo "  Jobs pendientes: $remaining_jobs - Tiempo restante: $(( (end_time - $(date +%s)) / 60 )) min"
          sleep 30
        done
        
        echo "‚è∞ Timeout alcanzado. Procediendo con acciones..."
        exit 1
      register: wait_result
      changed_when: false
      failed_when: wait_result.rc != 0 and wait_result.rc != 1
      
    - name: Verificar si quedan jobs despu√©s del timeout
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u" 2>/dev/null || echo ""
      register: remaining_jobs
      changed_when: false
      failed_when: false
      when: wait_result.rc == 1  # Solo si timeout se alcanz√≥
      
    - name: Salir si no quedan jobs despu√©s de la espera
      meta: end_play
      when: wait_result.rc == 0 or remaining_jobs.stdout == "" or remaining_jobs.stdout_lines | length == 0
      
    - name: DRAINEAR NODO (solo si timeout se alcanz√≥ y hay jobs pendientes)
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="Auto-requeue: timeout alcanzado, procesando jobs pendientes"
      register: drain_result
      failed_when: false
      when: wait_result.rc == 1 and remaining_jobs.stdout_lines | length > 0
      
    - name: Esperar que el drain se aplique
      pause:
        seconds: 5
      when: wait_result.rc == 1 and remaining_jobs.stdout_lines | length > 0
        
    - name: Cancelar jobs de usuarios problem√°ticos (despu√©s de timeout)
      shell: |
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "üö´ Cancelando jobs de usuarios con /tmp excesivo..."
        cancelled_count=0
        
        {% for job_line in remaining_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        if [ $is_problematic -eq 1 ]; then
          echo "  ‚ùå Cancelando job $jobid del usuario problem√°tico $jobuser"
          scancel $jobid
          cancelled_count=$((cancelled_count + 1))
        fi
        {% endfor %}
        
        echo "Total cancelados: $cancelled_count"
      args:
        executable: /bin/bash
      register: cancel_result
      when: wait_result.rc == 1 and problematic_users.stdout_lines | length > 0 and remaining_jobs.stdout_lines | length > 0
      
    - name: Esperar que se cancelen los jobs
      pause:
        seconds: 10
      when: wait_result.rc == 1 and problematic_users.stdout_lines | length > 0 and remaining_jobs.stdout_lines | length > 0
          
    - name: Requeuear jobs restantes despu√©s de timeout (usuarios limpios) con cambio de nodo
      shell: |
        problematic_users=""
        {% if problematic_users.stdout_lines | length > 0 %}
        {% for line in problematic_users.stdout_lines %}
        problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
        {% endfor %}
        {% endif %}
        
        echo "‚ôªÔ∏è  Requeuing jobs de usuarios sin problemas (despu√©s de timeout)..."
        requeued_count=0
        
        {% for job_line in remaining_jobs.stdout_lines %}
        jobid=$(echo "{{ job_line }}" | cut -d: -f1)
        jobuser=$(echo "{{ job_line }}" | cut -d: -f2)
        
        is_problematic=0
        for puser in $problematic_users; do
          if [ "$jobuser" = "$puser" ]; then
            is_problematic=1
            break
          fi
        done
        
        if [ $is_problematic -eq 0 ]; then
          echo "  ‚úÖ Requeuing job $jobid del usuario $jobuser"
          
          {% if alternative_node.stdout != "NO_ALTERNATIVE" %}
          job_script=$(scontrol show job $jobid | grep "Command=" | sed 's/.*Command=//')
          
          if [ ! -z "$job_script" ] && [ -f "$job_script" ]; then
            echo "    Moviendo a nodo {{ alternative_node.stdout }}"
            scancel $jobid
            sleep 2
            sbatch --nodelist={{ alternative_node.stdout }} "$job_script"
            requeued_count=$((requeued_count + 1))
          else
            echo "    Requeue normal (no se pudo obtener script)"
            scontrol requeue $jobid 2>/dev/null || true
          fi
          {% else %}
          echo "    Requeue sin cambio de nodo"
          scontrol requeue $jobid
          requeued_count=$((requeued_count + 1))
          {% endif %}
        fi
        {% endfor %}
        
        echo "Total requeued: $requeued_count"
      args:
        executable: /bin/bash
      register: requeue_result
      failed_when: false
      when: wait_result.rc == 1 and remaining_jobs.stdout_lines | length > 0
          
    - name: Esperar que los jobs se requeueen
      pause:
        seconds: 30
      when: wait_result.rc == 1 and remaining_jobs.stdout_lines | length > 0
          
    - name: Reactivar nodo
      shell: |
        scontrol update NodeName={{ hostname_full.stdout }} State=RESUME
      register: resume_result
      failed_when: false
      when: wait_result.rc == 1
      
    - name: Limpiar archivo temporal
      file:
        path: /tmp/problematic_users.txt
        state: absent
      
    - name: Resultado final
      debug:
        msg: |
          {% if wait_result.rc == 0 %}
          "‚úÖ TODOS LOS JOBS COMPLETARON NORMALMENTE dentro del timeout"
          {% else %}
          "‚úÖ PROCESO COMPLETADO despu√©s de timeout en {{ hostname_full.stdout }}"
          "Jobs originales: {{ all_jobs.stdout_lines | length }}"
          "Jobs pendientes despu√©s de timeout: {{ remaining_jobs.stdout_lines | length }}"
          "Usuarios problem√°ticos: {{ problematic_users.stdout_lines | length }}"
          "Nodo destino: {{ alternative_node.stdout }}"
          {% endif %}
