- name: Requeue autom√°tico CON CAMBIO DE NODO y control de /tmp
  hosts: all
  become: yes
  vars:
    ansible_become_exe: "sudo -n"
    tmp_size_limit_gb: 1  # L√≠mite en GB para /tmp por usuario
    
  tasks:
    - name: Obtener hostname completo
      command: hostname -f
      register: hostname_full
      changed_when: false
      
    - name: Detectar usuarios con archivos grandes en /tmp
      shell: |
        for file in /tmp/*; do
          if [ -e "$file" ]; then
            size_kb=$(du -sk "$file" 2>/dev/null | awk '{print $1}')
            owner=$(stat -c '%U' "$file" 2>/dev/null)
            
            if [ ! -z "$size_kb" ] && [ ! -z "$owner" ]; then
              size_gb=$(echo "scale=2; $size_kb / 1024 / 1024" | bc)
              
              # Comparar con l√≠mite
              over_limit=$(echo "$size_gb > {{ tmp_size_limit_gb }}" | bc)
              
              if [ "$over_limit" -eq 1 ]; then
                echo "$owner $size_gb"
              fi
            fi
          fi
        done | awk '{users[$1]+=$2} END {for (u in users) if (users[u] > {{ tmp_size_limit_gb }}) print u, users[u]}' | sort -u
      register: problematic_users
      changed_when: false
      failed_when: false
      
    - name: Mostrar usuarios problem√°ticos
      debug:
        msg: |
          "‚ö†Ô∏è  Usuarios con uso excesivo de /tmp (>{{ tmp_size_limit_gb }}GB):"
          {% if problematic_users.stdout_lines | length > 0 %}
          {% for line in problematic_users.stdout_lines %}
          "  - {{ line }}"
          {% endfor %}
          {% else %}
          "  Ninguno detectado"
          {% endif %}
      
    - name: Encontrar nodo alternativo
      shell: |
        sinfo -p short -h -o "%N" | tr ',' '\n' | grep -v {{ hostname_full.stdout }} | grep -v down | head -1 || echo "NO_ALTERNATIVE"
      register: alternative_node
      changed_when: false
      failed_when: false
      
    - name: Verificar jobs en este nodo
      shell: |
        squeue -h -w {{ hostname_full.stdout }} -o "%i:%u:%j:%T:%N:%P" 2>/dev/null || echo "NO_JOBS"
      register: running_jobs
      changed_when: false
      failed_when: false
      
    - name: Mostrar estado actual
      debug:
        msg: |
          "Nodo actual: {{ hostname_full.stdout }}"
          "Nodo alternativo: {{ alternative_node.stdout }}"
          "Jobs encontrados: {{ running_jobs.stdout_lines if running_jobs.stdout != 'NO_JOBS' else 'NINGUNO' }}"
        
    - name: Salir si no hay jobs
      debug:
        msg: "‚úÖ No hay jobs en {{ hostname_full.stdout }} - nada que hacer"
      when: running_jobs.stdout == "NO_JOBS" or running_jobs.stdout == ""
      
    - name: Continuar si hay jobs
      block:
        - name: Cancelar jobs de usuarios problem√°ticos
          shell: |
            cancelled_jobs=""
            {% if problematic_users.stdout_lines | length > 0 %}
            echo "üö´ Cancelando jobs de usuarios con /tmp excesivo..."
            {% for line in problematic_users.stdout_lines %}
            user=$(echo "{{ line }}" | awk '{print $1}')
            size=$(echo "{{ line }}" | awk '{print $2}')
            echo "  Cancelando jobs de $user (${size}GB en /tmp)"
            
            # Guardar IDs de jobs antes de cancelar
            for jobid in $(squeue -h -u $user -w {{ hostname_full.stdout }} -o "%i" 2>/dev/null); do
              cancelled_jobs="$cancelled_jobs $jobid"
              echo "    Job $jobid marcado para cancelaci√≥n"
            done
            
            scancel -u $user -w {{ hostname_full.stdout }}
            {% endfor %}
            echo "CANCELLED_JOBS:$cancelled_jobs"
            {% else %}
            echo "‚úÖ No hay usuarios problem√°ticos - todos los jobs son elegibles"
            echo "CANCELLED_JOBS:"
            {% endif %}
          args:
            executable: /bin/bash
          register: cancel_result
          failed_when: false
          
        - name: Esperar que se cancelen los jobs
          pause:
            seconds: 5
          when: problematic_users.stdout_lines | length > 0
          
        - name: Drainear nodo
          shell: |
            scontrol update NodeName={{ hostname_full.stdout }} State=DRAIN Reason="Auto-requeue to {{ alternative_node.stdout }}"
          register: drain_result
          failed_when: false
          
        - name: Esperar 15 segundos
          pause:
            seconds: 15
          
        - name: Requeuear jobs restantes con cambio de nodo
          shell: |
            # Crear lista de usuarios problem√°ticos
            problematic_users=""
            {% if problematic_users.stdout_lines | length > 0 %}
            {% for line in problematic_users.stdout_lines %}
            problematic_users="$problematic_users $(echo '{{ line }}' | awk '{print $1}')"
            {% endfor %}
            {% endif %}
            
            for jobline in $(squeue -h -w {{ hostname_full.stdout }} -o "%i:%u" 2>/dev/null); do
              jobid=$(echo $jobline | cut -d: -f1)
              jobuser=$(echo $jobline | cut -d: -f2)
              
              # Verificar si el usuario es problem√°tico
              skip=0
              for puser in $problematic_users; do
                if [ "$jobuser" = "$puser" ]; then
                  echo "‚è≠Ô∏è  Saltando job $jobid del usuario problem√°tico $jobuser"
                  skip=1
                  break
                fi
              done
              
              if [ $skip -eq 0 ]; then
                echo "‚úÖ Procesando job $jobid del usuario $jobuser"
                {% if alternative_node.stdout != "NO_ALTERNATIVE" %}
                  echo "  Moviendo job $jobid a {{ alternative_node.stdout }}"
                  scancel $jobid
                  sleep 2
                  scontrol show job $jobid | grep "Command=" | cut -d= -f2 | xargs sbatch --nodelist={{ alternative_node.stdout }}
                {% else %}
                  echo "  Requeue normal del job $jobid"
                  scontrol requeue $jobid
                {% endif %}
              fi
            done
          args:
            executable: /bin/bash
          register: requeue_result
          failed_when: false
          
        - name: Esperar 30 segundos
          pause:
            seconds: 30
          
        - name: Reactivar nodo
          shell: |
            scontrol update NodeName={{ hostname_full.stdout }} State=RESUME
          register: resume_result
          failed_when: false
          
        - name: Resultado final
          debug:
            msg:
              - "‚úÖ REQUEUE COMPLETADO en {{ hostname_full.stdout }}"
              - "Jobs totales procesados: {{ running_jobs.stdout_lines | length }}"
              - "Usuarios problem√°ticos cancelados: {{ problematic_users.stdout_lines | length }}"
              - "Nodo destino: {{ alternative_node.stdout }}"
      when: running_jobs.stdout != "NO_JOBS" and running_jobs.stdout != ""
